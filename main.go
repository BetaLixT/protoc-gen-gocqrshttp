package main

import (
	"fmt"
	"strings"

	// "google.golang.org/genproto/googleapis/api/annotations"
	// "google.golang.org/genproto/googleapis/api/serviceconfig"
	"google.golang.org/protobuf/compiler/protogen"
	// "google.golang.org/protobuf/proto"
	// "google.golang.org/protobuf/runtime/protoimpl"
	// "google.golang.org/protobuf/types/descriptorpb"
	// "google.golang.org/protobuf/proto"
	// "google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if f.Generate {
				if err := GenerateFile(p, f); err != nil {
					return err
				}
			}
		}

		return nil
	})
}

func GenerateFile(
	plugin *protogen.Plugin,
	file *protogen.File,
) error {
	isGenerated := false
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			isGenerated = true
		}
	}

	if !isGenerated {
		return nil
	}
	plugin.SupportedFeatures = 1

	gofilename := file.GeneratedFilenamePrefix + ".http.go"
	gohttp := plugin.NewGeneratedFile(gofilename, file.GoImportPath)

	gohttp.P("// Code generated by protoc-gen-gohttp. DO NOT EDIT.")
	gohttp.P("// source: ", file.Desc.Path())
	gohttp.P()
	gohttp.P("package ", file.GoPackageName)

	yamlfilename := file.GeneratedFilenamePrefix + ".http.yaml"
	openapi := plugin.NewGeneratedFile(yamlfilename, file.GoImportPath)

	openapi.P("# Code generated by protoc-gen-gohttp. DO NOT EDIT.")
	openapi.P("# source: ", file.Desc.Path())

	cnqs := map[string]struct{}{}
	srvs := []Server{}
	for _, srv := range file.Services {
		// if err := genService(g, srv); err != nil {
		// 	return err
		// }

		pths := []APIPath{}
		for _, rpc := range srv.Methods {
			if _, ok := cnqs[rpc.Input.GoIdent.GoName]; !ok {
				cnqs[rpc.Input.GoIdent.GoName] = struct{}{}
			} else {
				return fmt.Errorf("command/query used multiple times %s", rpc.Input.GoIdent.GoName)
			}

			var path string
			if strings.Contains(rpc.Input.GoIdent.GoName, "Command") {
				cmd := toPrivateName(strings.TrimSuffix(rpc.Input.GoIdent.GoName, "Command"))
				path = "/commands/" + cmd
			} else if strings.Contains(rpc.Input.GoIdent.GoName, "Query") {
				cmd := toPrivateName(strings.TrimSuffix(rpc.Input.GoIdent.GoName, "Query"))
				path = "/queries/" + cmd
			} else {
				return fmt.Errorf("non command/query model used as input %s", rpc.Input.GoIdent.GoName)
			}

			pths = append(pths, APIPath{
				Method:     rpc,
				Path:       path,
				Summary:    string(rpc.Comments.Leading),
				Description: string(rpc.Comments.Leading),
				HTTPMethod: "POST",
			})
		}
		srvs = append(srvs, Server{
			Service: srv,
			Paths:   pths,
		})
	}

	err := generateHTTPServers(srvs, gohttp)
	if err != nil {
		return err
	}

	return generateOpenAPI(srvs, openapi, file)
}
